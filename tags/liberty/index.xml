<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>liberty on ebullient·works</title><link>/tags/liberty.html</link><description>Recent content in liberty on ebullient·works</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 27 Nov 2017 00:00:00 +0000</lastBuildDate><atom:link href="/tags/liberty/index.xml" rel="self" type="application/rss+xml"/><item><title>Java EE ebullience — airhacks.fm podcast with Adam Bien</title><link>/2017/11/27/airhacks-fm.html</link><pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate><guid>/2017/11/27/airhacks-fm.html</guid><description>I spent an excellent few hours recording a podcast with Adam Bien!</description></item><item><title>Game On! Explore microservices with a text-based adventure</title><link>/2016/05/16/game-on-explore-microservices-with-a-text-based-adventure.html</link><pubDate>Mon, 16 May 2016 00:00:00 +0000</pubDate><guid>/2016/05/16/game-on-explore-microservices-with-a-text-based-adventure.html</guid><description>Microservices: the buzz is everywhere. Given the breadth of technologies related to the term, it can be difficult to get a full picture of what a Microservices architecture should look like, or to understand why it is said that microservices architectures both remove and introduce complexity at the same time. Game On! is a throwback text-based adventure built to help you explore microservices concepts.
Continue with post on IBM developerWorks</description></item><item><title>Swagger-first API design</title><link>/2016/01/27/swagger-first-api-design.html</link><pubDate>Wed, 27 Jan 2016 00:00:00 +0000</pubDate><guid>/2016/01/27/swagger-first-api-design.html</guid><description>&lt;p>I've been working for the past few months on building Game On! a microservices-based application that is intended to show both what a microservices architecture looks like, and to make it easy for people to play with such a system without having to start from the ground up themselves.&lt;/p>
&lt;p>We started with a best-guess set of services, and over time, it became pretty apparent that our first pass at a map building service (the Concierge) was both misleading in purpose and insufficient in function. It did serve its purpose, filling in for service discovery in a way, but we were growing beyond what the service could do. &lt;/p></description></item><item><title>Microservices and WAS Liberty</title><link>/2015/12/11/microservices-and-was-liberty.html</link><pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/11/microservices-and-was-liberty.html</guid><description>Home to Microservices and WAS Liberty resources, which provide background information, getting started guidance, best practices, and methodologies.
Continue with post on IBM developerWorks</description></item><item><title>Secure Microservices: API Keys, Access Tokens, and Signed JWTs</title><link>/2015/12/04/secure-microservices-api-keys-access-tokens-and-signed-jwts.html</link><pubDate>Fri, 04 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/04/secure-microservices-api-keys-access-tokens-and-signed-jwts.html</guid><description>Some samples demonstrating how to secure your microservices using API keys, access tokens, and JSON Web Tokens (JWTs).
Continue with post on IBM developerWorks</description></item><item><title>Using Grok filters to parse Liberty Logs</title><link>/2015/09/02/logstash-and-liberty-optimizing-data-collection-for-the-cloud.html</link><pubDate>Wed, 02 Sep 2015 00:00:00 +0000</pubDate><guid>/2015/09/02/logstash-and-liberty-optimizing-data-collection-for-the-cloud.html</guid><description>Note: Originally posted on Continue with post on IBMDeveloperWorks. Some of this content is old, but the gist is still useful.
Microservice architectures are highly distributed, with services provided by individual processes that are scaled independently. Understanding and maintaining overall system health becomes increasingly difficult as the system grows; it becomes impractical to look at services instance-by-instance. Monitoring systems like nagios help, but what happens when things go wrong? It is not always possible (much less easy) to ssh into any given system. In some environments the filesystem used by any given instance is transient; when the process stops, the filesystem is cleaned up, including all the logs!
The ELK stack (Elasticsearch, Logstash, and Kibana) is a commonly used system for gathering data (both logs and metrics), and allowing that data to be aggregated, analyzed, visualized, and searched in useful ways.
In this post, I'll focus on getting the most out of WAS Liberty logs using logstash. This isn't the only way: the IBM WebSphere Liberty buildpack in Bluemix, for example, uses loggregator (Cloud Foundry) rather than logstash. But I do hope that this gives you some ideas for how to make the logging capabilities in WAS Liberty work for your environment.
Getting useful information to system streams When operating on its own, WAS Liberty produces a few different log files by default:
&amp;ldquo;console&amp;rdquo; output is lightly formatted and contains no timestamps. Failure/error messages and System.err are routed to STDERR, while other important messages and System.out, are routed to STDOUT. When run in the background via server start, both streams are collected into a console.log file. messages.log also collects System out, System err, as well as a larger subset of messages (including INFO). trace.log only appears if detailed trace is enabled. It includes output from all enabled log sources, including System.out and System.err. Having log messages go directly to STDOUT and/or STDERR is a good environment-agnostic practice for microservices (and is also one of the 12-factors). It is a pretty simple change to get formatted Liberty logs writing to STDOUT. To ensure we don't miss any messages from server bootstrap and startup, we'll do this via a bootstrap.properties file that contains:
# Write WLP logs to stdout directly com.ibm.ws.logging.trace.file.name=stdout As you might infer, this re-routes what would go to trace.log to STDOUT. Before this change, STDOUT when running Liberty looks something like this:
$ wlp/bin/server run Launching defaultServer (WebSphere Application Server 8.5.5.6/wlp-1.0.9.cl50620150610-1749) on Java HotSpot(TM) 64-Bit Server VM, version 1.7.0_72-b14 (en_US) [AUDIT ] CWWKE0001I: The server defaultServer has been launched. Afterwards, it looks more like (notice the leading timestamp and fixed fields):
$ wlp/bin/server run Launching defaultServer (WebSphere Application Server 8.5.5.6/wlp-1.0.9.cl50620150610-1749) on Java HotSpot(TM) 64-Bit Server VM, version 1.7.0_72-b14 (en_US) [8/25/15 12:40:44:479 EDT] 00000001 id= com.ibm.ws.kernel.launch.internal.FrameworkManager A CWWKE0001I: The server defaultServer has been launched. In some cases, this might be enough. If you're running Liberty in the foreground in a Docker container, Liberty's formatted log entries would now be spilling out as the Docker container's STDOUT. If the hosting environment does post-processing on that output, you may have nothing left to do.
Using logstash to post-process logs However, we can use logstash to process Liberty log output to produce more robust events. How you link logstash and Liberty together will depend on how and where Liberty is running. As a bare minimum useful for testing filters, you can try something like the following:
$ wlp/bin/server run | logstash -f /path/to/logstash.conf You can use the -e command line option to define your filters inline, but I'm starting with the configuration file up front because I'll spend the rest of the post adding things to it.
Changing the output / making sure it works I'll start with the log-processing equivalent of &amp;ldquo;Hello World&amp;rdquo;. Edit your logstash.conf file to contain:
input { stdin { } } output { stdout { } } You get back pretty much exactly what you had before (with a leading message about logstash startup being complete and additional leading logstash timestamps):
$ wlp/bin/server run | logstash -f logstash.conf Logstash startup completed 2015-08-26T22:23:04.587Z ec2db0f13b8f Launching defaultServer (WebSphere Application Server 8.5.5.6/wlp-1.0.9.cl50620150610-1749) on OpenJDK 64-Bit Server VM, version 1.8.0_45-internal-b14 (en) 2015-08-26T22:23:04.588Z ec2db0f13b8f [8/26/15 22:22:45:918 UTC] 00000001 id= com.ibm.ws.kernel.launch.internal.FrameworkManager A CWWKE0001I: The server defaultServer has been launched. This does increase the amount of time it takes before we can see that the server has started properly, as the messages piped through logstash get delayed a bit while logstash starts itself.
Debugging Given we're going to start doing crazy things, we'll want to be able to see how we changed what logstash stores for each entry. We'll use the rubydebug codec to do this:
output { stdout { codec =&amp;gt; rubydebug } ... } Once we add that, those first few lines now look like this (please do scroll right):
Handle multiple lines We're going to start adding filters in the next few sections. The first we will add is for multi-line output.
input { ... } filter { # Combine lines that do not start with &amp;quot;[&amp;quot; or # contain &amp;quot;WebSphere Application Server&amp;quot; with the previous message multiline { pattern =&amp;gt; &amp;quot;(^[)|(WebSphere Application Server)&amp;quot; negate =&amp;gt; true what =&amp;gt; &amp;quot;previous&amp;quot; } ## MORE HERE. } output { ... } Note first that the pattern is negated; we're asserting that any line that does not match the pattern is a continuation, and should be lumped together with the previous line.
Liberty log entries (and even wrapped System.out or System.err output) all start with a bracketed timestamp that looks something like, [8/26/15 22:22:45:918 UTC]. But, remember that first line of Liberty trace? &amp;ldquo;Launching defaultServer (WebSphere Application Server 8.5.5.6/wlp-1.0.9.cl50620150610-1749)&amp;quot;. Since this is the very first line of output, we have to account for it as a standalone line (go ahead and take it out if you don't believe me&amp;hellip; ).
Without logstash (just using raw Liberty), you might see the following output if you use an include to reconfigure your httpEndpoint. Note that the Liberty log timestamp is only on the first line, as this is a multi-line entry that is (further) not a stack trace:</description></item><item><title>Don't Wait! Play with Async EE7 instead</title><link>/2015/08/21/don-t-wait-build-responsive-applications-with-java-ee-7-instead.html</link><pubDate>Fri, 21 Aug 2015 00:00:00 +0000</pubDate><guid>/2015/08/21/don-t-wait-build-responsive-applications-with-java-ee-7-instead.html</guid><description>An overview of what Java EE 7 brings in support of responsive applications with samples on GitHub. These samples were also used at IBM InterConnect earlier in the year.
Continue with post on IBM DeveloperWorks</description></item><item><title>Building portable, 12-factor microservices with WAS Liberty and Bluemix</title><link>/2015/08/12/building-portable-12-factor-microservices-with-was-liberty-and-bluemix.html</link><pubDate>Wed, 12 Aug 2015 00:00:00 +0000</pubDate><guid>/2015/08/12/building-portable-12-factor-microservices-with-was-liberty-and-bluemix.html</guid><description>An overview of 12-factor applications, and how a 12-factor application can be built using WAS Liberty and Bluemix.
Continue with post on IBM DeveloperWorks</description></item></channel></rss>